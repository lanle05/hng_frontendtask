"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var build_exports = {};
__export(build_exports, {
  build: () => build
});
module.exports = __toCommonJS(build_exports);
var import_ts_morph = require("ts-morph");
var import_fs = require("fs");
var import_path = require("path");
var import_build_utils = require("@vercel/build-utils");
var import_static_config = require("@vercel/static-config");
var import_nft = require("@vercel/nft");
var import_utils = require("./utils");
var import_hydrogen = require("./hydrogen");
const remixBuilderPkg = JSON.parse(
  (0, import_fs.readFileSync)((0, import_path.join)(__dirname, "../package.json"), "utf8")
);
const remixRunDevForkVersion = remixBuilderPkg.devDependencies["@remix-run/dev"];
const DEFAULTS_PATH = (0, import_path.join)(__dirname, "../defaults");
const edgeServerSrcPromise = import_fs.promises.readFile(
  (0, import_path.join)(DEFAULTS_PATH, "server-edge.mjs"),
  "utf-8"
);
const nodeServerSrcPromise = import_fs.promises.readFile(
  (0, import_path.join)(DEFAULTS_PATH, "server-node.mjs"),
  "utf-8"
);
const VERCEL_REMIX_MIN_VERSION = "1.10.0";
const REMIX_RUN_DEV_MIN_VERSION = "1.15.0";
const REMIX_RUN_DEV_MAX_VERSION = remixRunDevForkVersion.slice(
  remixRunDevForkVersion.lastIndexOf("@") + 1
);
const build = async ({
  entrypoint,
  files,
  workPath,
  repoRootPath,
  config,
  meta = {}
}) => {
  const { installCommand, buildCommand } = config;
  await (0, import_build_utils.download)(files, workPath, meta);
  const mountpoint = (0, import_path.dirname)(entrypoint);
  const entrypointFsDirname = (0, import_path.join)(workPath, mountpoint);
  const nodeVersion = await (0, import_build_utils.getNodeVersion)(
    entrypointFsDirname,
    void 0,
    config,
    meta
  );
  const { cliType, packageJsonPath, lockfileVersion } = await (0, import_build_utils.scanParentDirs)(
    entrypointFsDirname
  );
  if (!packageJsonPath) {
    throw new Error("Failed to locate `package.json` file in your project");
  }
  const pkgRaw = await import_fs.promises.readFile(packageJsonPath, "utf8");
  const pkg = JSON.parse(pkgRaw);
  const spawnOpts = (0, import_build_utils.getSpawnOptions)(meta, nodeVersion);
  if (!spawnOpts.env) {
    spawnOpts.env = {};
  }
  spawnOpts.env = (0, import_build_utils.getEnvForPackageManager)({
    cliType,
    lockfileVersion,
    nodeVersion,
    env: spawnOpts.env
  });
  if (typeof installCommand === "string") {
    if (installCommand.trim()) {
      console.log(`Running "install" command: \`${installCommand}\`...`);
      await (0, import_build_utils.execCommand)(installCommand, {
        ...spawnOpts,
        cwd: entrypointFsDirname
      });
    } else {
      console.log(`Skipping "install" command...`);
    }
  } else {
    await (0, import_build_utils.runNpmInstall)(entrypointFsDirname, [], spawnOpts, meta, nodeVersion);
  }
  const isHydrogen2 = pkg.dependencies?.["@shopify/remix-oxygen"] || pkg.devDependencies?.["@shopify/remix-oxygen"];
  const remixRunDevPath = await (0, import_utils.ensureResolvable)(
    entrypointFsDirname,
    repoRootPath,
    "@remix-run/dev"
  );
  const remixRunDevPkg = JSON.parse(
    (0, import_fs.readFileSync)((0, import_path.join)(remixRunDevPath, "package.json"), "utf8")
  );
  const remixVersion = remixRunDevPkg.version;
  const remixConfig = await (0, import_utils.chdirAndReadConfig)(
    remixRunDevPath,
    entrypointFsDirname,
    packageJsonPath
  );
  const { serverEntryPoint, appDirectory } = remixConfig;
  const remixRoutes = Object.values(remixConfig.routes);
  const depsToAdd = [];
  if (!isHydrogen2 && remixRunDevPkg.name !== "@vercel/remix-run-dev") {
    const remixDevForkVersion = (0, import_utils.resolveSemverMinMax)(
      REMIX_RUN_DEV_MIN_VERSION,
      REMIX_RUN_DEV_MAX_VERSION,
      remixVersion
    );
    depsToAdd.push(
      `@remix-run/dev@npm:@vercel/remix-run-dev@${remixDevForkVersion}`
    );
  }
  const userEntryServerFile = (0, import_utils.findEntry)(appDirectory, "entry.server");
  if (!userEntryServerFile) {
    await import_fs.promises.copyFile(
      (0, import_path.join)(DEFAULTS_PATH, "entry.server.jsx"),
      (0, import_path.join)(appDirectory, "entry.server.jsx")
    );
    if (!pkg.dependencies["@vercel/remix"]) {
      const vercelRemixVersion = (0, import_utils.resolveSemverMinMax)(
        VERCEL_REMIX_MIN_VERSION,
        REMIX_RUN_DEV_MAX_VERSION,
        remixVersion
      );
      depsToAdd.push(`@vercel/remix@${vercelRemixVersion}`);
    }
  }
  if (depsToAdd.length) {
    await (0, import_utils.addDependencies)(cliType, depsToAdd, {
      ...spawnOpts,
      cwd: entrypointFsDirname
    });
  }
  const userEntryClientFile = (0, import_utils.findEntry)(
    remixConfig.appDirectory,
    "entry.client"
  );
  if (!userEntryClientFile) {
    await import_fs.promises.copyFile(
      (0, import_path.join)(DEFAULTS_PATH, "entry.client.react.jsx"),
      (0, import_path.join)(appDirectory, "entry.client.jsx")
    );
  }
  let remixConfigWrapped = false;
  let serverEntryPointAbs;
  let originalServerEntryPoint;
  const remixConfigPath = (0, import_utils.findConfig)(entrypointFsDirname, "remix.config");
  const renamedRemixConfigPath = remixConfigPath ? `${remixConfigPath}.original${(0, import_path.extname)(remixConfigPath)}` : void 0;
  let serverBundles;
  const serverBundlesMap = /* @__PURE__ */ new Map();
  const resolvedConfigsMap = /* @__PURE__ */ new Map();
  try {
    const project = new import_ts_morph.Project();
    const staticConfigsMap = /* @__PURE__ */ new Map();
    for (const route of remixRoutes) {
      const routePath = (0, import_path.join)(remixConfig.appDirectory, route.file);
      let staticConfig = (0, import_static_config.getConfig)(project, routePath);
      if (staticConfig && isHydrogen2) {
        console.log(
          "WARN: `export const config` is currently not supported for Hydrogen v2 apps"
        );
        staticConfig = null;
      }
      staticConfigsMap.set(route, staticConfig);
    }
    for (const route of remixRoutes) {
      const config2 = (0, import_utils.getResolvedRouteConfig)(
        route,
        remixConfig.routes,
        staticConfigsMap,
        isHydrogen2
      );
      resolvedConfigsMap.set(route, config2);
    }
    for (const route of remixRoutes) {
      if ((0, import_utils.isLayoutRoute)(route.id, remixRoutes))
        continue;
      const config2 = resolvedConfigsMap.get(route);
      if (!config2) {
        throw new Error(`Expected resolved config for "${route.id}"`);
      }
      const hash = (0, import_utils.calculateRouteConfigHash)(config2);
      let routesForHash = serverBundlesMap.get(hash);
      if (!Array.isArray(routesForHash)) {
        routesForHash = [];
        serverBundlesMap.set(hash, routesForHash);
      }
      routesForHash.push(route);
    }
    serverBundles = Array.from(serverBundlesMap.entries()).map(
      ([hash, routes2]) => {
        const runtime = resolvedConfigsMap.get(routes2[0])?.runtime ?? "nodejs";
        return {
          serverBuildPath: isHydrogen2 ? (0, import_path.relative)(entrypointFsDirname, remixConfig.serverBuildPath) : `${(0, import_path.relative)(
            entrypointFsDirname,
            (0, import_path.dirname)(remixConfig.serverBuildPath)
          )}/build-${runtime}-${hash}.js`,
          routes: routes2.map((r) => r.id)
        };
      }
    );
    if (!isHydrogen2 && remixConfigPath && renamedRemixConfigPath) {
      await import_fs.promises.rename(remixConfigPath, renamedRemixConfigPath);
      let patchedConfig;
      if ((0, import_utils.isESM)(renamedRemixConfigPath)) {
        patchedConfig = `import config from './${(0, import_path.basename)(
          renamedRemixConfigPath
        )}';
config.serverBuildTarget = undefined;
config.serverModuleFormat = 'cjs';
config.serverPlatform = 'node';
config.serverBuildPath = undefined;
config.serverBundles = ${JSON.stringify(serverBundles)};
export default config;`;
      } else {
        patchedConfig = `const config = require('./${(0, import_path.basename)(
          renamedRemixConfigPath
        )}');
config.serverBuildTarget = undefined;
config.serverModuleFormat = 'cjs';
config.serverPlatform = 'node';
config.serverBuildPath = undefined;
config.serverBundles = ${JSON.stringify(serverBundles)};
module.exports = config;`;
      }
      await import_fs.promises.writeFile(remixConfigPath, patchedConfig);
      remixConfigWrapped = true;
    }
    if (isHydrogen2) {
      if (remixConfig.serverEntryPoint) {
        serverEntryPointAbs = (0, import_path.join)(
          entrypointFsDirname,
          remixConfig.serverEntryPoint
        );
        originalServerEntryPoint = await import_fs.promises.readFile(
          serverEntryPointAbs,
          "utf8"
        );
        const patchedServerEntryPoint = (0, import_hydrogen.patchHydrogenServer)(
          project,
          serverEntryPointAbs
        );
        if (patchedServerEntryPoint) {
          (0, import_build_utils.debug)(
            `Patched Hydrogen server file: ${remixConfig.serverEntryPoint}`
          );
          await import_fs.promises.writeFile(serverEntryPointAbs, patchedServerEntryPoint);
        }
      } else {
        console.log('WARN: No "server" field found in Remix config');
      }
    }
    spawnOpts.env.NODE_ENV = "production";
    if (buildCommand) {
      (0, import_build_utils.debug)(`Executing build command "${buildCommand}"`);
      await (0, import_build_utils.execCommand)(buildCommand, {
        ...spawnOpts,
        cwd: entrypointFsDirname
      });
    } else {
      if (hasScript("vercel-build", pkg)) {
        (0, import_build_utils.debug)(`Executing "yarn vercel-build"`);
        await (0, import_build_utils.runPackageJsonScript)(
          entrypointFsDirname,
          "vercel-build",
          spawnOpts
        );
      } else if (hasScript("build", pkg)) {
        (0, import_build_utils.debug)(`Executing "yarn build"`);
        await (0, import_build_utils.runPackageJsonScript)(entrypointFsDirname, "build", spawnOpts);
      } else {
        await (0, import_build_utils.execCommand)("remix build", {
          ...spawnOpts,
          cwd: entrypointFsDirname
        });
      }
    }
  } finally {
    const cleanupOps = [];
    if (remixConfigWrapped && remixConfigPath && renamedRemixConfigPath) {
      cleanupOps.push(
        import_fs.promises.rename(renamedRemixConfigPath, remixConfigPath).then(
          () => (0, import_build_utils.debug)(`Restored original "${(0, import_path.basename)(remixConfigPath)}" file`)
        )
      );
    }
    if (serverEntryPointAbs && originalServerEntryPoint) {
      cleanupOps.push(
        import_fs.promises.writeFile(serverEntryPointAbs, originalServerEntryPoint).then(
          () => (0, import_build_utils.debug)(`Restored original "${(0, import_path.basename)(serverEntryPointAbs)}" file`)
        )
      );
    }
    await Promise.all(cleanupOps);
  }
  await Promise.all([
    (0, import_utils.ensureResolvable)(
      entrypointFsDirname,
      repoRootPath,
      "@remix-run/server-runtime"
    ),
    !isHydrogen2 ? (0, import_utils.ensureResolvable)(entrypointFsDirname, repoRootPath, "@remix-run/node") : null
  ]);
  const staticDir = (0, import_path.join)(
    remixConfig.assetsBuildDirectory,
    ...remixConfig.publicPath.replace(/^\/|\/$/g, "").split("/").map((_) => "..")
  );
  const [staticFiles, ...functions] = await Promise.all([
    (0, import_build_utils.glob)("**", staticDir),
    ...serverBundles.map((bundle) => {
      const firstRoute = remixConfig.routes[bundle.routes[0]];
      const config2 = resolvedConfigsMap.get(firstRoute) ?? {
        runtime: "nodejs"
      };
      if (config2.runtime === "edge") {
        return createRenderEdgeFunction(
          entrypointFsDirname,
          repoRootPath,
          (0, import_path.join)(entrypointFsDirname, bundle.serverBuildPath),
          serverEntryPoint,
          remixVersion,
          config2
        );
      }
      return createRenderNodeFunction(
        nodeVersion,
        entrypointFsDirname,
        repoRootPath,
        (0, import_path.join)(entrypointFsDirname, bundle.serverBuildPath),
        serverEntryPoint,
        remixVersion,
        config2
      );
    })
  ]);
  const output = staticFiles;
  const routes = [
    {
      src: "^/build/(.*)$",
      headers: { "cache-control": "public, max-age=31536000, immutable" },
      continue: true
    },
    {
      handle: "filesystem"
    }
  ];
  for (const route of remixRoutes) {
    if ((0, import_utils.isLayoutRoute)(route.id, remixRoutes))
      continue;
    const { path, rePath } = (0, import_utils.getPathFromRoute)(route, remixConfig.routes);
    if (!path) {
      continue;
    }
    const funcIndex = serverBundles.findIndex((bundle) => {
      return bundle.routes.includes(route.id);
    });
    const func = functions[funcIndex];
    if (!func) {
      throw new Error(`Could not determine server bundle for "${route.id}"`);
    }
    output[path] = func instanceof import_build_utils.EdgeFunction ? (
      // `EdgeFunction` currently requires the "name" property to be set.
      // Ideally this property will be removed, at which point we can
      // return the same `edgeFunction` instance instead of creating a
      // new one for each page.
      new import_build_utils.EdgeFunction({
        ...func,
        name: path
      })
    ) : func;
    const re = (0, import_utils.getRegExpFromPath)(rePath);
    if (re) {
      routes.push({
        src: re.source,
        dest: path
      });
    }
  }
  if (!output["404"]) {
    const edgeFunctionIndex = Array.from(serverBundlesMap.values()).findIndex(
      (routes2) => {
        const runtime = resolvedConfigsMap.get(routes2[0])?.runtime;
        return runtime === "edge";
      }
    );
    const func = edgeFunctionIndex !== -1 ? functions[edgeFunctionIndex] : functions[0];
    output["404"] = func instanceof import_build_utils.EdgeFunction ? new import_build_utils.EdgeFunction({ ...func, name: "404" }) : func;
  }
  routes.push({
    src: "/(.*)",
    dest: "/404"
  });
  return { routes, output, framework: { version: remixVersion } };
};
function hasScript(scriptName, pkg) {
  const scripts = pkg && pkg.scripts || {};
  return typeof scripts[scriptName] === "string";
}
async function createRenderNodeFunction(nodeVersion, entrypointDir, rootDir, serverBuildPath, serverEntryPoint, remixVersion, config) {
  const files = {};
  let handler = (0, import_path.relative)(rootDir, serverBuildPath);
  let handlerPath = (0, import_path.join)(rootDir, handler);
  if (!serverEntryPoint) {
    const baseServerBuildPath = (0, import_path.basename)(serverBuildPath, ".js");
    handler = (0, import_path.join)((0, import_path.dirname)(handler), `server-${baseServerBuildPath}.mjs`);
    handlerPath = (0, import_path.join)(rootDir, handler);
    const nodeServerSrc = await nodeServerSrcPromise;
    await writeEntrypointFile(
      handlerPath,
      nodeServerSrc.replace(
        "@remix-run/dev/server-build",
        `./${baseServerBuildPath}.js`
      ),
      rootDir
    );
  }
  const trace = await (0, import_nft.nodeFileTrace)([handlerPath], {
    base: rootDir,
    processCwd: entrypointDir
  });
  for (const warning of trace.warnings) {
    (0, import_build_utils.debug)(`Warning from trace: ${warning.message}`);
  }
  for (const file of trace.fileList) {
    files[file] = await import_build_utils.FileFsRef.fromFsPath({ fsPath: (0, import_path.join)(rootDir, file) });
  }
  const fn = new import_build_utils.NodejsLambda({
    files,
    handler,
    runtime: nodeVersion.runtime,
    shouldAddHelpers: false,
    shouldAddSourcemapSupport: false,
    operationType: "SSR",
    supportsResponseStreaming: true,
    regions: config.regions,
    memory: config.memory,
    maxDuration: config.maxDuration,
    framework: {
      slug: "remix",
      version: remixVersion
    }
  });
  return fn;
}
async function createRenderEdgeFunction(entrypointDir, rootDir, serverBuildPath, serverEntryPoint, remixVersion, config) {
  const files = {};
  let handler = (0, import_path.relative)(rootDir, serverBuildPath);
  let handlerPath = (0, import_path.join)(rootDir, handler);
  if (!serverEntryPoint) {
    const baseServerBuildPath = (0, import_path.basename)(serverBuildPath, ".js");
    handler = (0, import_path.join)((0, import_path.dirname)(handler), `server-${baseServerBuildPath}.mjs`);
    handlerPath = (0, import_path.join)(rootDir, handler);
    const edgeServerSrc = await edgeServerSrcPromise;
    await writeEntrypointFile(
      handlerPath,
      edgeServerSrc.replace(
        "@remix-run/dev/server-build",
        `./${baseServerBuildPath}.js`
      ),
      rootDir
    );
  }
  let remixRunVercelPkgJson;
  const trace = await (0, import_nft.nodeFileTrace)([handlerPath], {
    base: rootDir,
    processCwd: entrypointDir,
    conditions: ["edge-light", "browser", "module", "import", "require"],
    async readFile(fsPath) {
      let source;
      try {
        source = await import_fs.promises.readFile(fsPath);
      } catch (err) {
        if (err.code === "ENOENT" || err.code === "EISDIR") {
          return null;
        }
        throw err;
      }
      if ((0, import_path.basename)(fsPath) === "package.json") {
        const pkgJson = JSON.parse(source.toString());
        if (pkgJson.name === "@remix-run/vercel") {
          pkgJson.browser = "dist/edge.js";
          pkgJson.dependencies["@remix-run/server-runtime"] = pkgJson.dependencies["@remix-run/node"];
          if (!remixRunVercelPkgJson) {
            remixRunVercelPkgJson = JSON.stringify(pkgJson, null, 2) + "\n";
            const vercelEdgeEntrypointPath = (0, import_path.join)(
              DEFAULTS_PATH,
              "vercel-edge-entrypoint.js"
            );
            const vercelEdgeEntrypointDest = (0, import_path.join)(
              (0, import_path.dirname)(fsPath),
              "dist/edge.js"
            );
            await import_fs.promises.copyFile(
              vercelEdgeEntrypointPath,
              vercelEdgeEntrypointDest
            );
          }
        }
        for (const prop of ["browser", "module"]) {
          const val = pkgJson[prop];
          if (typeof val === "string") {
            pkgJson.main = val;
            source = JSON.stringify(pkgJson);
            break;
          }
        }
      }
      return source;
    }
  });
  for (const warning of trace.warnings) {
    (0, import_build_utils.debug)(`Warning from trace: ${warning.message}`);
  }
  for (const file of trace.fileList) {
    if (remixRunVercelPkgJson && file.endsWith(`@remix-run${import_path.sep}vercel${import_path.sep}package.json`)) {
      files[file] = new import_build_utils.FileBlob({ data: remixRunVercelPkgJson });
    } else {
      files[file] = await import_build_utils.FileFsRef.fromFsPath({ fsPath: (0, import_path.join)(rootDir, file) });
    }
  }
  const fn = new import_build_utils.EdgeFunction({
    files,
    deploymentTarget: "v8-worker",
    name: "render",
    entrypoint: handler,
    regions: config.regions,
    framework: {
      slug: "remix",
      version: remixVersion
    }
  });
  return fn;
}
async function writeEntrypointFile(path, data, rootDir) {
  try {
    await import_fs.promises.writeFile(path, data);
  } catch (err) {
    if (err.code === "ENOENT") {
      throw new Error(
        `The "${(0, import_path.relative)(
          rootDir,
          (0, import_path.dirname)(path)
        )}" directory does not exist. Please contact support at https://vercel.com/help.`
      );
    }
    throw err;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  build
});
//# sourceMappingURL=build.js.map
