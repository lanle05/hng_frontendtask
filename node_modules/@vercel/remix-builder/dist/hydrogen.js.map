{
  "version": 3,
  "sources": ["../src/hydrogen.ts"],
  "sourcesContent": ["import { basename } from 'path';\nimport { Node, Project, SyntaxKind } from 'ts-morph';\n\n/**\n * For Hydrogen v2, the `server.ts` file exports a signature like:\n *\n * ```\n * export default {\n *   async fetch(\n *     request: Request,\n *     env: Env,\n *     executionContext: ExecutionContext,\n *   ): Promise<Response>;\n * }\n * ```\n *\n * Here we parse the AST of that file so that we can:\n *\n *  1. Convert the signature to be compatible with Vercel Edge functions\n *     (i.e. `export default (res: Response): Promise<Response>`).\n *\n *  2. Track usages of the `env` parameter which (which gets removed),\n *     so that we can create that object based on `process.env`.\n */\nexport function patchHydrogenServer(\n  project: Project,\n  serverEntryPoint: string\n) {\n  const sourceFile = project.addSourceFileAtPath(serverEntryPoint);\n  const defaultExportSymbol = sourceFile.getDescendantsOfKind(\n    SyntaxKind.ExportAssignment\n  )[0];\n  const envProperties: string[] = [];\n\n  if (!defaultExportSymbol) {\n    console.log(\n      `WARN: No default export found in \"${basename(serverEntryPoint)}\"`\n    );\n    return;\n  }\n\n  const objectLiteral = defaultExportSymbol.getFirstChildByKind(\n    SyntaxKind.ObjectLiteralExpression\n  );\n  if (!Node.isObjectLiteralExpression(objectLiteral)) {\n    console.log(\n      `WARN: Default export in \"${basename(\n        serverEntryPoint\n      )}\" does not conform to Oxygen syntax`\n    );\n    return;\n  }\n\n  const fetchMethod = objectLiteral.getProperty('fetch');\n  if (!fetchMethod || !Node.isMethodDeclaration(fetchMethod)) {\n    console.log(\n      `WARN: Default export in \"${basename(\n        serverEntryPoint\n      )}\" does not conform to Oxygen syntax`\n    );\n    return;\n  }\n\n  const parameters = fetchMethod.getParameters();\n\n  // Find usages of the env object within the fetch method\n  const envParam = parameters[1];\n  const envParamName = envParam.getName();\n  if (envParam) {\n    fetchMethod.forEachDescendant(node => {\n      if (\n        Node.isPropertyAccessExpression(node) &&\n        node.getExpression().getText() === envParamName\n      ) {\n        envProperties.push(node.getName());\n      }\n    });\n  }\n\n  // Vercel does not support the Web Cache API, so find\n  // and replace `caches.open()` calls with `undefined`\n  fetchMethod.forEachDescendant(node => {\n    if (\n      Node.isCallExpression(node) &&\n      node.getExpression().getText() === 'caches.open'\n    ) {\n      node.replaceWithText(`undefined /* ${node.getText()} */`);\n    }\n  });\n\n  // Remove the 'env' parameter to match Vercel's Edge signature\n  parameters.splice(1, 1);\n\n  // Construct the new function with the parameters and body of the original fetch method\n  const newFunction = `export default async function(${parameters\n    .map(p => p.getText())\n    .join(', ')}) ${fetchMethod.getBody()!.getText()}`;\n  defaultExportSymbol.replaceWithText(newFunction);\n\n  const defaultEnvVars = {\n    SESSION_SECRET: 'foobar',\n    PUBLIC_STORE_DOMAIN: 'mock.shop',\n  };\n  const envCode = `const env = { ${envProperties\n    .map(name => `${name}: process.env.${name}`)\n    .join(', ')} };\\n${Object.entries(defaultEnvVars)\n    .map(\n      ([k, v]) =>\n        `if (!env.${k}) { env.${k} = ${JSON.stringify(\n          v\n        )}; console.warn('Warning: ${JSON.stringify(\n          k\n        )} env var not set - using default value ${JSON.stringify(v)}'); }`\n    )\n    .join('\\n')}`;\n\n  const updatedCodeString = sourceFile.getFullText();\n  return `${envCode}\\n${updatedCodeString}`;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAyB;AACzB,sBAA0C;AAuBnC,SAAS,oBACd,SACA,kBACA;AACA,QAAM,aAAa,QAAQ,oBAAoB,gBAAgB;AAC/D,QAAM,sBAAsB,WAAW;AAAA,IACrC,2BAAW;AAAA,EACb,EAAE,CAAC;AACH,QAAM,gBAA0B,CAAC;AAEjC,MAAI,CAAC,qBAAqB;AACxB,YAAQ;AAAA,MACN,yCAAqC,sBAAS,gBAAgB,CAAC;AAAA,IACjE;AACA;AAAA,EACF;AAEA,QAAM,gBAAgB,oBAAoB;AAAA,IACxC,2BAAW;AAAA,EACb;AACA,MAAI,CAAC,qBAAK,0BAA0B,aAAa,GAAG;AAClD,YAAQ;AAAA,MACN,gCAA4B;AAAA,QAC1B;AAAA,MACF,CAAC;AAAA,IACH;AACA;AAAA,EACF;AAEA,QAAM,cAAc,cAAc,YAAY,OAAO;AACrD,MAAI,CAAC,eAAe,CAAC,qBAAK,oBAAoB,WAAW,GAAG;AAC1D,YAAQ;AAAA,MACN,gCAA4B;AAAA,QAC1B;AAAA,MACF,CAAC;AAAA,IACH;AACA;AAAA,EACF;AAEA,QAAM,aAAa,YAAY,cAAc;AAG7C,QAAM,WAAW,WAAW,CAAC;AAC7B,QAAM,eAAe,SAAS,QAAQ;AACtC,MAAI,UAAU;AACZ,gBAAY,kBAAkB,UAAQ;AACpC,UACE,qBAAK,2BAA2B,IAAI,KACpC,KAAK,cAAc,EAAE,QAAQ,MAAM,cACnC;AACA,sBAAc,KAAK,KAAK,QAAQ,CAAC;AAAA,MACnC;AAAA,IACF,CAAC;AAAA,EACH;AAIA,cAAY,kBAAkB,UAAQ;AACpC,QACE,qBAAK,iBAAiB,IAAI,KAC1B,KAAK,cAAc,EAAE,QAAQ,MAAM,eACnC;AACA,WAAK,gBAAgB,gBAAgB,KAAK,QAAQ,CAAC,KAAK;AAAA,IAC1D;AAAA,EACF,CAAC;AAGD,aAAW,OAAO,GAAG,CAAC;AAGtB,QAAM,cAAc,iCAAiC,WAClD,IAAI,OAAK,EAAE,QAAQ,CAAC,EACpB,KAAK,IAAI,CAAC,KAAK,YAAY,QAAQ,EAAG,QAAQ,CAAC;AAClD,sBAAoB,gBAAgB,WAAW;AAE/C,QAAM,iBAAiB;AAAA,IACrB,gBAAgB;AAAA,IAChB,qBAAqB;AAAA,EACvB;AACA,QAAM,UAAU,iBAAiB,cAC9B,IAAI,UAAQ,GAAG,IAAI,iBAAiB,IAAI,EAAE,EAC1C,KAAK,IAAI,CAAC;AAAA,EAAQ,OAAO,QAAQ,cAAc,EAC/C;AAAA,IACC,CAAC,CAAC,GAAG,CAAC,MACJ,YAAY,CAAC,WAAW,CAAC,MAAM,KAAK;AAAA,MAClC;AAAA,IACF,CAAC,4BAA4B,KAAK;AAAA,MAChC;AAAA,IACF,CAAC,0CAA0C,KAAK,UAAU,CAAC,CAAC;AAAA,EAChE,EACC,KAAK,IAAI,CAAC;AAEb,QAAM,oBAAoB,WAAW,YAAY;AACjD,SAAO,GAAG,OAAO;AAAA,EAAK,iBAAiB;AACzC;",
  "names": []
}
