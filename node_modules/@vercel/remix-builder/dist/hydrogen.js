"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var hydrogen_exports = {};
__export(hydrogen_exports, {
  patchHydrogenServer: () => patchHydrogenServer
});
module.exports = __toCommonJS(hydrogen_exports);
var import_path = require("path");
var import_ts_morph = require("ts-morph");
function patchHydrogenServer(project, serverEntryPoint) {
  const sourceFile = project.addSourceFileAtPath(serverEntryPoint);
  const defaultExportSymbol = sourceFile.getDescendantsOfKind(
    import_ts_morph.SyntaxKind.ExportAssignment
  )[0];
  const envProperties = [];
  if (!defaultExportSymbol) {
    console.log(
      `WARN: No default export found in "${(0, import_path.basename)(serverEntryPoint)}"`
    );
    return;
  }
  const objectLiteral = defaultExportSymbol.getFirstChildByKind(
    import_ts_morph.SyntaxKind.ObjectLiteralExpression
  );
  if (!import_ts_morph.Node.isObjectLiteralExpression(objectLiteral)) {
    console.log(
      `WARN: Default export in "${(0, import_path.basename)(
        serverEntryPoint
      )}" does not conform to Oxygen syntax`
    );
    return;
  }
  const fetchMethod = objectLiteral.getProperty("fetch");
  if (!fetchMethod || !import_ts_morph.Node.isMethodDeclaration(fetchMethod)) {
    console.log(
      `WARN: Default export in "${(0, import_path.basename)(
        serverEntryPoint
      )}" does not conform to Oxygen syntax`
    );
    return;
  }
  const parameters = fetchMethod.getParameters();
  const envParam = parameters[1];
  const envParamName = envParam.getName();
  if (envParam) {
    fetchMethod.forEachDescendant((node) => {
      if (import_ts_morph.Node.isPropertyAccessExpression(node) && node.getExpression().getText() === envParamName) {
        envProperties.push(node.getName());
      }
    });
  }
  fetchMethod.forEachDescendant((node) => {
    if (import_ts_morph.Node.isCallExpression(node) && node.getExpression().getText() === "caches.open") {
      node.replaceWithText(`undefined /* ${node.getText()} */`);
    }
  });
  parameters.splice(1, 1);
  const newFunction = `export default async function(${parameters.map((p) => p.getText()).join(", ")}) ${fetchMethod.getBody().getText()}`;
  defaultExportSymbol.replaceWithText(newFunction);
  const defaultEnvVars = {
    SESSION_SECRET: "foobar",
    PUBLIC_STORE_DOMAIN: "mock.shop"
  };
  const envCode = `const env = { ${envProperties.map((name) => `${name}: process.env.${name}`).join(", ")} };
${Object.entries(defaultEnvVars).map(
    ([k, v]) => `if (!env.${k}) { env.${k} = ${JSON.stringify(
      v
    )}; console.warn('Warning: ${JSON.stringify(
      k
    )} env var not set - using default value ${JSON.stringify(v)}'); }`
  ).join("\n")}`;
  const updatedCodeString = sourceFile.getFullText();
  return `${envCode}
${updatedCodeString}`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  patchHydrogenServer
});
//# sourceMappingURL=hydrogen.js.map
