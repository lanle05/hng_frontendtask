{
  "version": 3,
  "sources": ["../src/build.ts"],
  "sourcesContent": ["import { Project } from 'ts-morph';\nimport { readFileSync, promises as fs } from 'fs';\nimport { basename, dirname, extname, join, relative, sep } from 'path';\nimport {\n  debug,\n  download,\n  execCommand,\n  FileBlob,\n  FileFsRef,\n  getEnvForPackageManager,\n  getNodeVersion,\n  getSpawnOptions,\n  glob,\n  EdgeFunction,\n  NodejsLambda,\n  runNpmInstall,\n  runPackageJsonScript,\n  scanParentDirs,\n} from '@vercel/build-utils';\nimport { getConfig } from '@vercel/static-config';\nimport { nodeFileTrace } from '@vercel/nft';\nimport type {\n  BuildV2,\n  Files,\n  NodeVersion,\n  PackageJson,\n  BuildResultV2Typical,\n} from '@vercel/build-utils';\nimport type { ConfigRoute } from '@remix-run/dev/dist/config/routes';\nimport type { BaseFunctionConfig } from '@vercel/static-config';\nimport {\n  calculateRouteConfigHash,\n  findConfig,\n  getPathFromRoute,\n  getRegExpFromPath,\n  getResolvedRouteConfig,\n  isLayoutRoute,\n  ResolvedRouteConfig,\n  ResolvedNodeRouteConfig,\n  ResolvedEdgeRouteConfig,\n  findEntry,\n  chdirAndReadConfig,\n  addDependencies,\n  resolveSemverMinMax,\n  ensureResolvable,\n  isESM,\n} from './utils';\nimport { patchHydrogenServer } from './hydrogen';\n\ninterface ServerBundle {\n  serverBuildPath: string;\n  routes: string[];\n}\n\nconst remixBuilderPkg = JSON.parse(\n  readFileSync(join(__dirname, '../package.json'), 'utf8')\n);\nconst remixRunDevForkVersion =\n  remixBuilderPkg.devDependencies['@remix-run/dev'];\n\nconst DEFAULTS_PATH = join(__dirname, '../defaults');\n\nconst edgeServerSrcPromise = fs.readFile(\n  join(DEFAULTS_PATH, 'server-edge.mjs'),\n  'utf-8'\n);\nconst nodeServerSrcPromise = fs.readFile(\n  join(DEFAULTS_PATH, 'server-node.mjs'),\n  'utf-8'\n);\n\n// Minimum supported version of the `@vercel/remix` package\nconst VERCEL_REMIX_MIN_VERSION = '1.10.0';\n\n// Minimum supported version of the `@vercel/remix-run-dev` forked compiler\nconst REMIX_RUN_DEV_MIN_VERSION = '1.15.0';\n\n// Maximum version of `@vercel/remix-run-dev` fork\n// (and also `@vercel/remix` since they get published at the same time)\nconst REMIX_RUN_DEV_MAX_VERSION = remixRunDevForkVersion.slice(\n  remixRunDevForkVersion.lastIndexOf('@') + 1\n);\n\nexport const build: BuildV2 = async ({\n  entrypoint,\n  files,\n  workPath,\n  repoRootPath,\n  config,\n  meta = {},\n}) => {\n  const { installCommand, buildCommand } = config;\n\n  await download(files, workPath, meta);\n\n  const mountpoint = dirname(entrypoint);\n  const entrypointFsDirname = join(workPath, mountpoint);\n\n  // Run \"Install Command\"\n  const nodeVersion = await getNodeVersion(\n    entrypointFsDirname,\n    undefined,\n    config,\n    meta\n  );\n\n  const { cliType, packageJsonPath, lockfileVersion } = await scanParentDirs(\n    entrypointFsDirname\n  );\n\n  if (!packageJsonPath) {\n    throw new Error('Failed to locate `package.json` file in your project');\n  }\n\n  const pkgRaw = await fs.readFile(packageJsonPath, 'utf8');\n  const pkg = JSON.parse(pkgRaw);\n\n  const spawnOpts = getSpawnOptions(meta, nodeVersion);\n  if (!spawnOpts.env) {\n    spawnOpts.env = {};\n  }\n\n  spawnOpts.env = getEnvForPackageManager({\n    cliType,\n    lockfileVersion,\n    nodeVersion,\n    env: spawnOpts.env,\n  });\n\n  if (typeof installCommand === 'string') {\n    if (installCommand.trim()) {\n      console.log(`Running \"install\" command: \\`${installCommand}\\`...`);\n      await execCommand(installCommand, {\n        ...spawnOpts,\n        cwd: entrypointFsDirname,\n      });\n    } else {\n      console.log(`Skipping \"install\" command...`);\n    }\n  } else {\n    await runNpmInstall(entrypointFsDirname, [], spawnOpts, meta, nodeVersion);\n  }\n\n  const isHydrogen2 =\n    pkg.dependencies?.['@shopify/remix-oxygen'] ||\n    pkg.devDependencies?.['@shopify/remix-oxygen'];\n\n  // Determine the version of Remix based on the `@remix-run/dev`\n  // package version.\n  const remixRunDevPath = await ensureResolvable(\n    entrypointFsDirname,\n    repoRootPath,\n    '@remix-run/dev'\n  );\n  const remixRunDevPkg = JSON.parse(\n    readFileSync(join(remixRunDevPath, 'package.json'), 'utf8')\n  );\n  const remixVersion = remixRunDevPkg.version;\n\n  const remixConfig = await chdirAndReadConfig(\n    remixRunDevPath,\n    entrypointFsDirname,\n    packageJsonPath\n  );\n  const { serverEntryPoint, appDirectory } = remixConfig;\n  const remixRoutes = Object.values(remixConfig.routes);\n\n  const depsToAdd: string[] = [];\n\n  // Override the official `@remix-run/dev` package with the\n  // Vercel fork, which supports the `serverBundles` config\n  if (!isHydrogen2 && remixRunDevPkg.name !== '@vercel/remix-run-dev') {\n    const remixDevForkVersion = resolveSemverMinMax(\n      REMIX_RUN_DEV_MIN_VERSION,\n      REMIX_RUN_DEV_MAX_VERSION,\n      remixVersion\n    );\n    depsToAdd.push(\n      `@remix-run/dev@npm:@vercel/remix-run-dev@${remixDevForkVersion}`\n    );\n  }\n\n  // `app/entry.server.tsx` and `app/entry.client.tsx` are optional in Remix,\n  // so if either of those files are missing then add our own versions.\n  const userEntryServerFile = findEntry(appDirectory, 'entry.server');\n  if (!userEntryServerFile) {\n    await fs.copyFile(\n      join(DEFAULTS_PATH, 'entry.server.jsx'),\n      join(appDirectory, 'entry.server.jsx')\n    );\n    if (!pkg.dependencies['@vercel/remix']) {\n      // Dependency version resolution logic\n      // 1. Users app is on 1.9.0 -> we install the 1.10.0 (minimum) version of `@vercel/remix`.\n      // 2. Users app is on 1.11.0 (a version greater than 1.10.0 and less than the known max\n      //    published version) -> we install the (matching) 1.11.0 version of `@vercel/remix`.\n      // 3. Users app is on something greater than our latest version of the fork -> we install\n      //    the latest known published version of `@vercel/remix`.\n      const vercelRemixVersion = resolveSemverMinMax(\n        VERCEL_REMIX_MIN_VERSION,\n        REMIX_RUN_DEV_MAX_VERSION,\n        remixVersion\n      );\n      depsToAdd.push(`@vercel/remix@${vercelRemixVersion}`);\n    }\n  }\n\n  if (depsToAdd.length) {\n    await addDependencies(cliType, depsToAdd, {\n      ...spawnOpts,\n      cwd: entrypointFsDirname,\n    });\n  }\n\n  const userEntryClientFile = findEntry(\n    remixConfig.appDirectory,\n    'entry.client'\n  );\n  if (!userEntryClientFile) {\n    await fs.copyFile(\n      join(DEFAULTS_PATH, 'entry.client.react.jsx'),\n      join(appDirectory, 'entry.client.jsx')\n    );\n  }\n\n  let remixConfigWrapped = false;\n  let serverEntryPointAbs: string | undefined;\n  let originalServerEntryPoint: string | undefined;\n  const remixConfigPath = findConfig(entrypointFsDirname, 'remix.config');\n  const renamedRemixConfigPath = remixConfigPath\n    ? `${remixConfigPath}.original${extname(remixConfigPath)}`\n    : undefined;\n\n  // These get populated inside the try/catch below\n  let serverBundles: ServerBundle[];\n  const serverBundlesMap = new Map<string, ConfigRoute[]>();\n  const resolvedConfigsMap = new Map<ConfigRoute, ResolvedRouteConfig>();\n\n  try {\n    // Read the `export const config` (if any) for each route\n    const project = new Project();\n    const staticConfigsMap = new Map<ConfigRoute, BaseFunctionConfig | null>();\n    for (const route of remixRoutes) {\n      const routePath = join(remixConfig.appDirectory, route.file);\n      let staticConfig = getConfig(project, routePath);\n      if (staticConfig && isHydrogen2) {\n        console.log(\n          'WARN: `export const config` is currently not supported for Hydrogen v2 apps'\n        );\n        staticConfig = null;\n      }\n      staticConfigsMap.set(route, staticConfig);\n    }\n\n    for (const route of remixRoutes) {\n      const config = getResolvedRouteConfig(\n        route,\n        remixConfig.routes,\n        staticConfigsMap,\n        isHydrogen2\n      );\n      resolvedConfigsMap.set(route, config);\n    }\n\n    // Figure out which routes belong to which server bundles\n    // based on having common static config properties\n    for (const route of remixRoutes) {\n      if (isLayoutRoute(route.id, remixRoutes)) continue;\n\n      const config = resolvedConfigsMap.get(route);\n      if (!config) {\n        throw new Error(`Expected resolved config for \"${route.id}\"`);\n      }\n      const hash = calculateRouteConfigHash(config);\n\n      let routesForHash = serverBundlesMap.get(hash);\n      if (!Array.isArray(routesForHash)) {\n        routesForHash = [];\n        serverBundlesMap.set(hash, routesForHash);\n      }\n\n      routesForHash.push(route);\n    }\n\n    serverBundles = Array.from(serverBundlesMap.entries()).map(\n      ([hash, routes]) => {\n        const runtime = resolvedConfigsMap.get(routes[0])?.runtime ?? 'nodejs';\n        return {\n          serverBuildPath: isHydrogen2\n            ? relative(entrypointFsDirname, remixConfig.serverBuildPath)\n            : `${relative(\n                entrypointFsDirname,\n                dirname(remixConfig.serverBuildPath)\n              )}/build-${runtime}-${hash}.js`,\n          routes: routes.map(r => r.id),\n        };\n      }\n    );\n\n    // We need to patch the `remix.config.js` file to force some values necessary\n    // for a build that works on either Node.js or the Edge runtime\n    if (!isHydrogen2 && remixConfigPath && renamedRemixConfigPath) {\n      await fs.rename(remixConfigPath, renamedRemixConfigPath);\n\n      let patchedConfig: string;\n      // Figure out if the `remix.config` file is using ESM syntax\n      if (isESM(renamedRemixConfigPath)) {\n        patchedConfig = `import config from './${basename(\n          renamedRemixConfigPath\n        )}';\nconfig.serverBuildTarget = undefined;\nconfig.serverModuleFormat = 'cjs';\nconfig.serverPlatform = 'node';\nconfig.serverBuildPath = undefined;\nconfig.serverBundles = ${JSON.stringify(serverBundles)};\nexport default config;`;\n      } else {\n        patchedConfig = `const config = require('./${basename(\n          renamedRemixConfigPath\n        )}');\nconfig.serverBuildTarget = undefined;\nconfig.serverModuleFormat = 'cjs';\nconfig.serverPlatform = 'node';\nconfig.serverBuildPath = undefined;\nconfig.serverBundles = ${JSON.stringify(serverBundles)};\nmodule.exports = config;`;\n      }\n      await fs.writeFile(remixConfigPath, patchedConfig);\n      remixConfigWrapped = true;\n    }\n\n    // For Hydrogen v2, patch the `server.ts` file to be Vercel-compatible\n    if (isHydrogen2) {\n      if (remixConfig.serverEntryPoint) {\n        serverEntryPointAbs = join(\n          entrypointFsDirname,\n          remixConfig.serverEntryPoint\n        );\n        originalServerEntryPoint = await fs.readFile(\n          serverEntryPointAbs,\n          'utf8'\n        );\n        const patchedServerEntryPoint = patchHydrogenServer(\n          project,\n          serverEntryPointAbs\n        );\n        if (patchedServerEntryPoint) {\n          debug(\n            `Patched Hydrogen server file: ${remixConfig.serverEntryPoint}`\n          );\n          await fs.writeFile(serverEntryPointAbs, patchedServerEntryPoint);\n        }\n      } else {\n        console.log('WARN: No \"server\" field found in Remix config');\n      }\n    }\n\n    // Make `remix build` output production mode\n    spawnOpts.env.NODE_ENV = 'production';\n\n    // Run \"Build Command\"\n    if (buildCommand) {\n      debug(`Executing build command \"${buildCommand}\"`);\n      await execCommand(buildCommand, {\n        ...spawnOpts,\n        cwd: entrypointFsDirname,\n      });\n    } else {\n      if (hasScript('vercel-build', pkg)) {\n        debug(`Executing \"yarn vercel-build\"`);\n        await runPackageJsonScript(\n          entrypointFsDirname,\n          'vercel-build',\n          spawnOpts\n        );\n      } else if (hasScript('build', pkg)) {\n        debug(`Executing \"yarn build\"`);\n        await runPackageJsonScript(entrypointFsDirname, 'build', spawnOpts);\n      } else {\n        await execCommand('remix build', {\n          ...spawnOpts,\n          cwd: entrypointFsDirname,\n        });\n      }\n    }\n  } finally {\n    const cleanupOps: Promise<void>[] = [];\n    // Clean up our patched `remix.config.js` to be polite\n    if (remixConfigWrapped && remixConfigPath && renamedRemixConfigPath) {\n      cleanupOps.push(\n        fs\n          .rename(renamedRemixConfigPath, remixConfigPath)\n          .then(() =>\n            debug(`Restored original \"${basename(remixConfigPath)}\" file`)\n          )\n      );\n    }\n    // Restore original server entrypoint if it was modified (for Hydrogen v2)\n    if (serverEntryPointAbs && originalServerEntryPoint) {\n      cleanupOps.push(\n        fs\n          .writeFile(serverEntryPointAbs, originalServerEntryPoint)\n          .then(() =>\n            debug(`Restored original \"${basename(serverEntryPointAbs!)}\" file`)\n          )\n      );\n    }\n    await Promise.all(cleanupOps);\n  }\n\n  // This needs to happen before we run NFT to create the Node/Edge functions\n  await Promise.all([\n    ensureResolvable(\n      entrypointFsDirname,\n      repoRootPath,\n      '@remix-run/server-runtime'\n    ),\n    !isHydrogen2\n      ? ensureResolvable(entrypointFsDirname, repoRootPath, '@remix-run/node')\n      : null,\n  ]);\n\n  const staticDir = join(\n    remixConfig.assetsBuildDirectory,\n    ...remixConfig.publicPath\n      .replace(/^\\/|\\/$/g, '')\n      .split('/')\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      .map(_ => '..')\n  );\n  const [staticFiles, ...functions] = await Promise.all([\n    glob('**', staticDir),\n    ...serverBundles.map(bundle => {\n      const firstRoute = remixConfig.routes[bundle.routes[0]];\n      const config = resolvedConfigsMap.get(firstRoute) ?? {\n        runtime: 'nodejs',\n      };\n\n      if (config.runtime === 'edge') {\n        return createRenderEdgeFunction(\n          entrypointFsDirname,\n          repoRootPath,\n          join(entrypointFsDirname, bundle.serverBuildPath),\n          serverEntryPoint,\n          remixVersion,\n          config\n        );\n      }\n\n      return createRenderNodeFunction(\n        nodeVersion,\n        entrypointFsDirname,\n        repoRootPath,\n        join(entrypointFsDirname, bundle.serverBuildPath),\n        serverEntryPoint,\n        remixVersion,\n        config\n      );\n    }),\n  ]);\n\n  const output: BuildResultV2Typical['output'] = staticFiles;\n  const routes: any[] = [\n    {\n      src: '^/build/(.*)$',\n      headers: { 'cache-control': 'public, max-age=31536000, immutable' },\n      continue: true,\n    },\n    {\n      handle: 'filesystem',\n    },\n  ];\n\n  for (const route of remixRoutes) {\n    // Layout routes don't get a function / route added\n    if (isLayoutRoute(route.id, remixRoutes)) continue;\n\n    const { path, rePath } = getPathFromRoute(route, remixConfig.routes);\n\n    // If the route is a pathless layout route (at the root level)\n    // and doesn't have any sub-routes, then a function should not be created.\n    if (!path) {\n      continue;\n    }\n\n    const funcIndex = serverBundles.findIndex(bundle => {\n      return bundle.routes.includes(route.id);\n    });\n    const func = functions[funcIndex];\n\n    if (!func) {\n      throw new Error(`Could not determine server bundle for \"${route.id}\"`);\n    }\n\n    output[path] =\n      func instanceof EdgeFunction\n        ? // `EdgeFunction` currently requires the \"name\" property to be set.\n          // Ideally this property will be removed, at which point we can\n          // return the same `edgeFunction` instance instead of creating a\n          // new one for each page.\n          new EdgeFunction({\n            ...func,\n            name: path,\n          })\n        : func;\n\n    // If this is a dynamic route then add a Vercel route\n    const re = getRegExpFromPath(rePath);\n    if (re) {\n      routes.push({\n        src: re.source,\n        dest: path,\n      });\n    }\n  }\n\n  // Add a 404 path for not found pages to be server-side rendered by Remix.\n  // Use an edge function bundle if one was generated, otherwise use Node.js.\n  if (!output['404']) {\n    const edgeFunctionIndex = Array.from(serverBundlesMap.values()).findIndex(\n      routes => {\n        const runtime = resolvedConfigsMap.get(routes[0])?.runtime;\n        return runtime === 'edge';\n      }\n    );\n    const func =\n      edgeFunctionIndex !== -1 ? functions[edgeFunctionIndex] : functions[0];\n    output['404'] =\n      func instanceof EdgeFunction\n        ? new EdgeFunction({ ...func, name: '404' })\n        : func;\n  }\n  routes.push({\n    src: '/(.*)',\n    dest: '/404',\n  });\n\n  return { routes, output, framework: { version: remixVersion } };\n};\n\nfunction hasScript(scriptName: string, pkg: PackageJson | null) {\n  const scripts = (pkg && pkg.scripts) || {};\n  return typeof scripts[scriptName] === 'string';\n}\n\nasync function createRenderNodeFunction(\n  nodeVersion: NodeVersion,\n  entrypointDir: string,\n  rootDir: string,\n  serverBuildPath: string,\n  serverEntryPoint: string | undefined,\n  remixVersion: string,\n  config: ResolvedNodeRouteConfig\n): Promise<NodejsLambda> {\n  const files: Files = {};\n\n  let handler = relative(rootDir, serverBuildPath);\n  let handlerPath = join(rootDir, handler);\n  if (!serverEntryPoint) {\n    const baseServerBuildPath = basename(serverBuildPath, '.js');\n    handler = join(dirname(handler), `server-${baseServerBuildPath}.mjs`);\n    handlerPath = join(rootDir, handler);\n\n    // Copy the `server-node.mjs` file into the \"build\" directory\n    const nodeServerSrc = await nodeServerSrcPromise;\n    await writeEntrypointFile(\n      handlerPath,\n      nodeServerSrc.replace(\n        '@remix-run/dev/server-build',\n        `./${baseServerBuildPath}.js`\n      ),\n      rootDir\n    );\n  }\n\n  // Trace the handler with `@vercel/nft`\n  const trace = await nodeFileTrace([handlerPath], {\n    base: rootDir,\n    processCwd: entrypointDir,\n  });\n\n  for (const warning of trace.warnings) {\n    debug(`Warning from trace: ${warning.message}`);\n  }\n\n  for (const file of trace.fileList) {\n    files[file] = await FileFsRef.fromFsPath({ fsPath: join(rootDir, file) });\n  }\n\n  const fn = new NodejsLambda({\n    files,\n    handler,\n    runtime: nodeVersion.runtime,\n    shouldAddHelpers: false,\n    shouldAddSourcemapSupport: false,\n    operationType: 'SSR',\n    supportsResponseStreaming: true,\n    regions: config.regions,\n    memory: config.memory,\n    maxDuration: config.maxDuration,\n    framework: {\n      slug: 'remix',\n      version: remixVersion,\n    },\n  });\n\n  return fn;\n}\n\nasync function createRenderEdgeFunction(\n  entrypointDir: string,\n  rootDir: string,\n  serverBuildPath: string,\n  serverEntryPoint: string | undefined,\n  remixVersion: string,\n  config: ResolvedEdgeRouteConfig\n): Promise<EdgeFunction> {\n  const files: Files = {};\n\n  let handler = relative(rootDir, serverBuildPath);\n  let handlerPath = join(rootDir, handler);\n  if (!serverEntryPoint) {\n    const baseServerBuildPath = basename(serverBuildPath, '.js');\n    handler = join(dirname(handler), `server-${baseServerBuildPath}.mjs`);\n    handlerPath = join(rootDir, handler);\n\n    // Copy the `server-edge.mjs` file into the \"build\" directory\n    const edgeServerSrc = await edgeServerSrcPromise;\n    await writeEntrypointFile(\n      handlerPath,\n      edgeServerSrc.replace(\n        '@remix-run/dev/server-build',\n        `./${baseServerBuildPath}.js`\n      ),\n      rootDir\n    );\n  }\n\n  let remixRunVercelPkgJson: string | undefined;\n\n  // Trace the handler with `@vercel/nft`\n  const trace = await nodeFileTrace([handlerPath], {\n    base: rootDir,\n    processCwd: entrypointDir,\n    conditions: ['edge-light', 'browser', 'module', 'import', 'require'],\n    async readFile(fsPath) {\n      let source: Buffer | string;\n      try {\n        source = await fs.readFile(fsPath);\n      } catch (err: any) {\n        if (err.code === 'ENOENT' || err.code === 'EISDIR') {\n          return null;\n        }\n        throw err;\n      }\n      if (basename(fsPath) === 'package.json') {\n        // For Edge Functions, patch \"main\" field to prefer \"browser\" or \"module\"\n        const pkgJson = JSON.parse(source.toString());\n\n        // When `@remix-run/vercel` is detected, we need to modify the `package.json`\n        // to include the \"browser\" field so that the proper Edge entrypoint file\n        // is used. This is a temporary stop gap until this PR is merged:\n        // https://github.com/remix-run/remix/pull/5537\n        if (pkgJson.name === '@remix-run/vercel') {\n          pkgJson.browser = 'dist/edge.js';\n          pkgJson.dependencies['@remix-run/server-runtime'] =\n            pkgJson.dependencies['@remix-run/node'];\n\n          if (!remixRunVercelPkgJson) {\n            remixRunVercelPkgJson = JSON.stringify(pkgJson, null, 2) + '\\n';\n\n            // Copy in the edge entrypoint so that NFT can properly resolve it\n            const vercelEdgeEntrypointPath = join(\n              DEFAULTS_PATH,\n              'vercel-edge-entrypoint.js'\n            );\n            const vercelEdgeEntrypointDest = join(\n              dirname(fsPath),\n              'dist/edge.js'\n            );\n            await fs.copyFile(\n              vercelEdgeEntrypointPath,\n              vercelEdgeEntrypointDest\n            );\n          }\n        }\n\n        for (const prop of ['browser', 'module']) {\n          const val = pkgJson[prop];\n          if (typeof val === 'string') {\n            pkgJson.main = val;\n\n            // Return the modified `package.json` to nft\n            source = JSON.stringify(pkgJson);\n            break;\n          }\n        }\n      }\n      return source;\n    },\n  });\n\n  for (const warning of trace.warnings) {\n    debug(`Warning from trace: ${warning.message}`);\n  }\n\n  for (const file of trace.fileList) {\n    if (\n      remixRunVercelPkgJson &&\n      file.endsWith(`@remix-run${sep}vercel${sep}package.json`)\n    ) {\n      // Use the modified `@remix-run/vercel` package.json which contains \"browser\" field\n      files[file] = new FileBlob({ data: remixRunVercelPkgJson });\n    } else {\n      files[file] = await FileFsRef.fromFsPath({ fsPath: join(rootDir, file) });\n    }\n  }\n\n  const fn = new EdgeFunction({\n    files,\n    deploymentTarget: 'v8-worker',\n    name: 'render',\n    entrypoint: handler,\n    regions: config.regions,\n    framework: {\n      slug: 'remix',\n      version: remixVersion,\n    },\n  });\n\n  return fn;\n}\n\nasync function writeEntrypointFile(\n  path: string,\n  data: string,\n  rootDir: string\n) {\n  try {\n    await fs.writeFile(path, data);\n  } catch (err: any) {\n    if (err.code === 'ENOENT') {\n      throw new Error(\n        `The \"${relative(\n          rootDir,\n          dirname(path)\n        )}\" directory does not exist. Please contact support at https://vercel.com/help.`\n      );\n    }\n    throw err;\n  }\n}\n"],
  "mappings": "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",
  "names": ["fs", "config", "routes"]
}
