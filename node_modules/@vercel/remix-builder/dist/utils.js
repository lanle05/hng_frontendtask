"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  _require: () => _require,
  addDependencies: () => addDependencies,
  calculateRouteConfigHash: () => calculateRouteConfigHash,
  chdirAndReadConfig: () => chdirAndReadConfig,
  ensureResolvable: () => ensureResolvable,
  findConfig: () => findConfig,
  findEntry: () => findEntry,
  getPathFromRoute: () => getPathFromRoute,
  getRegExpFromPath: () => getRegExpFromPath,
  getResolvedRouteConfig: () => getResolvedRouteConfig,
  getRouteIterator: () => getRouteIterator,
  isESM: () => isESM,
  isLayoutRoute: () => isLayoutRoute,
  resolveSemverMinMax: () => resolveSemverMinMax,
  syncEnv: () => syncEnv
});
module.exports = __toCommonJS(utils_exports);
var import_semver = __toESM(require("semver"));
var import_child_process = require("child_process");
var import_fs = require("fs");
var import_path = require("path");
var import_path_to_regexp = require("path-to-regexp");
var import_build_utils = require("@vercel/build-utils");
var import_build_utils2 = require("@vercel/build-utils");
const _require = eval("require");
const SPLAT_PATH = "/:params*";
const entryExts = [".js", ".jsx", ".ts", ".tsx"];
function findEntry(dir, basename2) {
  for (const ext of entryExts) {
    const file = (0, import_path.resolve)(dir, basename2 + ext);
    if ((0, import_fs.existsSync)(file))
      return (0, import_path.relative)(dir, file);
  }
  return void 0;
}
const configExts = [".js", ".cjs", ".mjs"];
function findConfig(dir, basename2) {
  for (const ext of configExts) {
    const name = basename2 + ext;
    const file = (0, import_path.join)(dir, name);
    if ((0, import_fs.existsSync)(file))
      return file;
  }
  return void 0;
}
function isEdgeRuntime(runtime) {
  return runtime === "edge" || runtime === "experimental-edge";
}
function getResolvedRouteConfig(route, routes, configs, isHydrogen2) {
  let runtime;
  let regions;
  let maxDuration;
  let memory;
  for (const currentRoute of getRouteIterator(route, routes)) {
    const staticConfig = configs.get(currentRoute);
    if (staticConfig) {
      if (typeof runtime === "undefined" && staticConfig.runtime) {
        runtime = isEdgeRuntime(staticConfig.runtime) ? "edge" : "nodejs";
      }
      if (typeof regions === "undefined") {
        regions = staticConfig.regions;
      }
      if (typeof maxDuration === "undefined") {
        maxDuration = staticConfig.maxDuration;
      }
      if (typeof memory === "undefined") {
        memory = staticConfig.memory;
      }
    }
  }
  if (Array.isArray(regions)) {
    regions = Array.from(new Set(regions)).sort();
  }
  if (isHydrogen2 || runtime === "edge") {
    return { runtime: "edge", regions };
  }
  if (regions && !Array.isArray(regions)) {
    throw new Error(
      `"regions" for route "${route.id}" must be an array of strings`
    );
  }
  return { runtime: "nodejs", regions, maxDuration, memory };
}
function calculateRouteConfigHash(config) {
  const str = JSON.stringify(config);
  return Buffer.from(str).toString("base64url");
}
function isLayoutRoute(routeId, routes) {
  return routes.some((r) => r.parentId === routeId);
}
function* getRouteIterator(route, routes) {
  let currentRoute = route;
  do {
    yield currentRoute;
    if (currentRoute.parentId) {
      currentRoute = routes[currentRoute.parentId];
    } else {
      break;
    }
  } while (currentRoute);
}
function getPathFromRoute(route, routes) {
  if (route.id === "root" || route.parentId === "root" && !route.path && route.index) {
    return { path: "index", rePath: "/index" };
  }
  const pathParts = [];
  const rePathParts = [];
  for (const currentRoute of getRouteIterator(route, routes)) {
    if (!currentRoute.path)
      continue;
    const currentRouteParts = currentRoute.path.split("/").reverse();
    for (const part of currentRouteParts) {
      if (part.endsWith("?")) {
        if (part.startsWith(":")) {
          pathParts.push(`(${part.substring(0, part.length - 1)})`);
          rePathParts.push(part);
        } else {
          const p = `(${part.substring(0, part.length - 1)})`;
          pathParts.push(p);
          rePathParts.push(`${p}?`);
        }
      } else {
        pathParts.push(part);
        rePathParts.push(part);
      }
    }
  }
  const path = pathParts.reverse().join("/");
  let rePath = rePathParts.reverse().join("/");
  rePath = rePath === "*" ? SPLAT_PATH : `/${rePath.replace(/\/\*$/, SPLAT_PATH)}`;
  return { path, rePath };
}
function getRegExpFromPath(rePath) {
  const keys = [];
  const re = (0, import_path_to_regexp.pathToRegexp)(rePath, keys);
  return keys.length > 0 ? re : false;
}
function syncEnv(source, dest) {
  const originalDest = { ...dest };
  Object.assign(dest, source);
  for (const key of Object.keys(dest)) {
    if (!(key in source)) {
      delete dest[key];
    }
  }
  return () => syncEnv(originalDest, dest);
}
async function chdirAndReadConfig(remixRunDevPath, dir, packageJsonPath) {
  const { readConfig } = await import((0, import_path.join)(remixRunDevPath, "dist/config.js"));
  const originalCwd = process.cwd();
  let modifiedPackageJson = false;
  const pkgRaw = await import_fs.promises.readFile(packageJsonPath, "utf8");
  const pkg = JSON.parse(pkgRaw);
  if (!pkg.dependencies?.["isbot"]) {
    pkg.dependencies.isbot = "latest";
    await import_fs.promises.writeFile(packageJsonPath, JSON.stringify(pkg));
    modifiedPackageJson = true;
  }
  const warn = console.warn;
  console.warn = import_build_utils.debug;
  let remixConfig;
  try {
    process.chdir(dir);
    remixConfig = await readConfig(dir);
  } finally {
    console.warn = warn;
    process.chdir(originalCwd);
    if (modifiedPackageJson) {
      await import_fs.promises.writeFile(packageJsonPath, pkgRaw);
    }
  }
  return remixConfig;
}
function addDependencies(cliType, names, opts = {}) {
  (0, import_build_utils.debug)("Installing additional dependencies:");
  for (const name of names) {
    (0, import_build_utils.debug)(` - ${name}`);
  }
  const args = [];
  if (cliType === "npm" || cliType === "pnpm") {
    args.push("install");
    if (opts.saveDev) {
      args.push("--save-dev");
    }
  } else {
    args.push("add");
    if (opts.saveDev) {
      args.push("--dev");
    }
    const yarnVersion = (0, import_child_process.execSync)("yarn -v", { encoding: "utf8" }).trim();
    const isYarnV1 = import_semver.default.satisfies(yarnVersion, "1");
    if (isYarnV1) {
      args.push("--ignore-workspace-root-check");
    }
  }
  if (cliType === "pnpm" && opts.cwd) {
    if ((0, import_fs.existsSync)((0, import_path.join)(opts.cwd, "pnpm-workspace.yaml"))) {
      args.push("--workspace-root");
    }
  }
  return (0, import_build_utils.spawnAsync)(cliType, args.concat(names), opts);
}
function resolveSemverMinMax(min, max, version) {
  const floored = import_semver.default.intersects(version, `>= ${min}`) ? version : min;
  return import_semver.default.intersects(floored, `<= ${max}`) ? floored : max;
}
async function ensureResolvable(start, base, pkgName) {
  try {
    const resolvedPkgPath = _require.resolve(`${pkgName}/package.json`, {
      paths: [start]
    });
    const resolvedPath = (0, import_path.dirname)(resolvedPkgPath);
    if (!(0, import_path.relative)(base, resolvedPath).startsWith(`..${import_path.sep}`)) {
      (0, import_build_utils.debug)(`"${pkgName}" resolved to '${resolvedPath}'`);
      return resolvedPath;
    }
  } catch (err) {
    if (err.code !== "MODULE_NOT_FOUND") {
      throw err;
    }
  }
  const pnpmDir = await (0, import_build_utils2.walkParentDirs)({
    base,
    start,
    filename: "node_modules/.pnpm"
  });
  if (pnpmDir) {
    const prefix = `${pkgName.replace("/", "+")}@`;
    const packages = await import_fs.promises.readdir(pnpmDir);
    const match = packages.find((p) => p.startsWith(prefix));
    if (match) {
      const pkgDir = (0, import_path.join)(pnpmDir, match, "node_modules", pkgName);
      await ensureSymlink(pkgDir, (0, import_path.join)(start, "node_modules"), pkgName);
      return pkgDir;
    }
  }
  const npmDir = await (0, import_build_utils2.walkParentDirs)({
    base,
    start,
    filename: "node_modules/.store"
  });
  if (npmDir) {
    const prefix = `${(0, import_path.basename)(pkgName)}@`;
    const prefixDir = (0, import_path.join)(npmDir, (0, import_path.dirname)(pkgName));
    const packages = await import_fs.promises.readdir(prefixDir);
    const match = packages.find((p) => p.startsWith(prefix));
    if (match) {
      const pkgDir = (0, import_path.join)(prefixDir, match, "node_modules", pkgName);
      await ensureSymlink(pkgDir, (0, import_path.join)(start, "node_modules"), pkgName);
      return pkgDir;
    }
  }
  throw new Error(
    `Failed to resolve "${pkgName}". To fix this error, add "${pkgName}" to "dependencies" in your \`package.json\` file.`
  );
}
async function ensureSymlink(target, nodeModulesDir, pkgName) {
  const symlinkPath = (0, import_path.join)(nodeModulesDir, pkgName);
  const symlinkDir = (0, import_path.dirname)(symlinkPath);
  const relativeTarget = (0, import_path.relative)(symlinkDir, target);
  try {
    const existingTarget = await import_fs.promises.readlink(symlinkPath);
    if (existingTarget === relativeTarget) {
      return;
    } else {
      await import_fs.promises.unlink(symlinkPath);
    }
  } catch (err) {
    if (err.code !== "ENOENT" && err.code !== "EINVAL") {
      throw err;
    }
  }
  await import_fs.promises.symlink(relativeTarget, symlinkPath);
  (0, import_build_utils.debug)(`Created symlink for "${pkgName}"`);
}
function isESM(path) {
  let isESM2 = false;
  try {
    _require(path);
  } catch (err) {
    isESM2 = err.code === "ERR_REQUIRE_ESM";
  }
  return isESM2;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  _require,
  addDependencies,
  calculateRouteConfigHash,
  chdirAndReadConfig,
  ensureResolvable,
  findConfig,
  findEntry,
  getPathFromRoute,
  getRegExpFromPath,
  getResolvedRouteConfig,
  getRouteIterator,
  isESM,
  isLayoutRoute,
  resolveSemverMinMax,
  syncEnv
});
//# sourceMappingURL=utils.js.map
