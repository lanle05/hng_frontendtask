{
  "version": 3,
  "sources": ["../src/utils.ts"],
  "sourcesContent": ["import semver from 'semver';\nimport { execSync } from 'child_process';\nimport { existsSync, promises as fs } from 'fs';\nimport { basename, dirname, join, relative, resolve, sep } from 'path';\nimport { pathToRegexp, Key } from 'path-to-regexp';\nimport { debug, spawnAsync } from '@vercel/build-utils';\nimport { walkParentDirs } from '@vercel/build-utils';\nimport type {\n  ConfigRoute,\n  RouteManifest,\n} from '@remix-run/dev/dist/config/routes';\nimport type { RemixConfig } from '@remix-run/dev/dist/config';\nimport type { BaseFunctionConfig } from '@vercel/static-config';\nimport type {\n  CliType,\n  SpawnOptionsExtended,\n} from '@vercel/build-utils/dist/fs/run-user-scripts';\n\nexport const _require: typeof require = eval('require');\n\nexport interface ResolvedNodeRouteConfig {\n  runtime: 'nodejs';\n  regions?: string[];\n  maxDuration?: number;\n  memory?: number;\n}\n\nexport interface ResolvedEdgeRouteConfig {\n  runtime: 'edge';\n  regions?: BaseFunctionConfig['regions'];\n}\n\nexport type ResolvedRouteConfig =\n  | ResolvedNodeRouteConfig\n  | ResolvedEdgeRouteConfig;\n\nexport interface ResolvedRoutePaths {\n  /**\n   * The full URL path of the route, as will be shown\n   * on the Functions tab in the deployment inspector.\n   */\n  path: string;\n  /**\n   * The full URL path of the route, but with syntax that\n   * is compatible with the `path-to-regexp` module.\n   */\n  rePath: string;\n}\n\nconst SPLAT_PATH = '/:params*';\n\nconst entryExts = ['.js', '.jsx', '.ts', '.tsx'];\n\nexport function findEntry(dir: string, basename: string): string | undefined {\n  for (const ext of entryExts) {\n    const file = resolve(dir, basename + ext);\n    if (existsSync(file)) return relative(dir, file);\n  }\n\n  return undefined;\n}\n\nconst configExts = ['.js', '.cjs', '.mjs'];\n\nexport function findConfig(dir: string, basename: string): string | undefined {\n  for (const ext of configExts) {\n    const name = basename + ext;\n    const file = join(dir, name);\n    if (existsSync(file)) return file;\n  }\n\n  return undefined;\n}\n\nfunction isEdgeRuntime(runtime: string): boolean {\n  return runtime === 'edge' || runtime === 'experimental-edge';\n}\n\nexport function getResolvedRouteConfig(\n  route: ConfigRoute,\n  routes: RouteManifest,\n  configs: Map<ConfigRoute, BaseFunctionConfig | null>,\n  isHydrogen2: boolean\n): ResolvedRouteConfig {\n  let runtime: ResolvedRouteConfig['runtime'] | undefined;\n  let regions: ResolvedRouteConfig['regions'];\n  let maxDuration: ResolvedNodeRouteConfig['maxDuration'];\n  let memory: ResolvedNodeRouteConfig['memory'];\n\n  for (const currentRoute of getRouteIterator(route, routes)) {\n    const staticConfig = configs.get(currentRoute);\n    if (staticConfig) {\n      if (typeof runtime === 'undefined' && staticConfig.runtime) {\n        runtime = isEdgeRuntime(staticConfig.runtime) ? 'edge' : 'nodejs';\n      }\n      if (typeof regions === 'undefined') {\n        regions = staticConfig.regions;\n      }\n      if (typeof maxDuration === 'undefined') {\n        maxDuration = staticConfig.maxDuration;\n      }\n      if (typeof memory === 'undefined') {\n        memory = staticConfig.memory;\n      }\n    }\n  }\n\n  if (Array.isArray(regions)) {\n    regions = Array.from(new Set(regions)).sort();\n  }\n\n  if (isHydrogen2 || runtime === 'edge') {\n    return { runtime: 'edge', regions };\n  }\n\n  if (regions && !Array.isArray(regions)) {\n    throw new Error(\n      `\"regions\" for route \"${route.id}\" must be an array of strings`\n    );\n  }\n\n  return { runtime: 'nodejs', regions, maxDuration, memory };\n}\n\nexport function calculateRouteConfigHash(config: ResolvedRouteConfig): string {\n  const str = JSON.stringify(config);\n  return Buffer.from(str).toString('base64url');\n}\n\nexport function isLayoutRoute(\n  routeId: string,\n  routes: Pick<ConfigRoute, 'id' | 'parentId'>[]\n): boolean {\n  return routes.some(r => r.parentId === routeId);\n}\n\nexport function* getRouteIterator(route: ConfigRoute, routes: RouteManifest) {\n  let currentRoute: ConfigRoute = route;\n  do {\n    yield currentRoute;\n    if (currentRoute.parentId) {\n      currentRoute = routes[currentRoute.parentId];\n    } else {\n      break;\n    }\n  } while (currentRoute);\n}\n\nexport function getPathFromRoute(\n  route: ConfigRoute,\n  routes: RouteManifest\n): ResolvedRoutePaths {\n  if (\n    route.id === 'root' ||\n    (route.parentId === 'root' && !route.path && route.index)\n  ) {\n    return { path: 'index', rePath: '/index' };\n  }\n\n  const pathParts: string[] = [];\n  const rePathParts: string[] = [];\n\n  for (const currentRoute of getRouteIterator(route, routes)) {\n    if (!currentRoute.path) continue;\n    const currentRouteParts = currentRoute.path.split('/').reverse();\n    for (const part of currentRouteParts) {\n      if (part.endsWith('?')) {\n        if (part.startsWith(':')) {\n          // Optional path parameter\n          pathParts.push(`(${part.substring(0, part.length - 1)})`);\n          rePathParts.push(part);\n        } else {\n          // Optional static segment\n          const p = `(${part.substring(0, part.length - 1)})`;\n          pathParts.push(p);\n          rePathParts.push(`${p}?`);\n        }\n      } else {\n        pathParts.push(part);\n        rePathParts.push(part);\n      }\n    }\n  }\n\n  const path = pathParts.reverse().join('/');\n\n  // Replace \"/*\" at the end to handle \"splat routes\"\n  let rePath = rePathParts.reverse().join('/');\n  rePath =\n    rePath === '*' ? SPLAT_PATH : `/${rePath.replace(/\\/\\*$/, SPLAT_PATH)}`;\n\n  return { path, rePath };\n}\n\nexport function getRegExpFromPath(rePath: string): RegExp | false {\n  const keys: Key[] = [];\n  const re = pathToRegexp(rePath, keys);\n  return keys.length > 0 ? re : false;\n}\n\n/**\n * Updates the `dest` process.env object to match the `source` one.\n * A function is returned to restore the the `dest` env back to how\n * it was originally.\n */\nexport function syncEnv(source: NodeJS.ProcessEnv, dest: NodeJS.ProcessEnv) {\n  const originalDest = { ...dest };\n  Object.assign(dest, source);\n  for (const key of Object.keys(dest)) {\n    if (!(key in source)) {\n      delete dest[key];\n    }\n  }\n\n  return () => syncEnv(originalDest, dest);\n}\n\nexport async function chdirAndReadConfig(\n  remixRunDevPath: string,\n  dir: string,\n  packageJsonPath: string\n) {\n  const { readConfig }: typeof import('@remix-run/dev/dist/config') =\n    await import(join(remixRunDevPath, 'dist/config.js'));\n\n  const originalCwd = process.cwd();\n\n  // As of Remix v1.14.0, reading the config may trigger adding\n  // \"isbot\" as a dependency, and `npm`/`pnpm`/`yarn` may be invoked.\n  // We want to prevent that behavior, so trick `readConfig()`\n  // into thinking that \"isbot\" is already installed.\n  let modifiedPackageJson = false;\n  const pkgRaw = await fs.readFile(packageJsonPath, 'utf8');\n  const pkg = JSON.parse(pkgRaw);\n  if (!pkg.dependencies?.['isbot']) {\n    pkg.dependencies.isbot = 'latest';\n    await fs.writeFile(packageJsonPath, JSON.stringify(pkg));\n    modifiedPackageJson = true;\n  }\n\n  // Suppress any warnings emitted from `readConfig()` to avoid\n  // printing them > 1 time. They will already be printed during\n  // `remix build` when invoking the Build Command.\n  const warn = console.warn;\n  console.warn = debug;\n\n  let remixConfig: RemixConfig;\n  try {\n    process.chdir(dir);\n    remixConfig = await readConfig(dir);\n  } finally {\n    console.warn = warn;\n    process.chdir(originalCwd);\n    if (modifiedPackageJson) {\n      await fs.writeFile(packageJsonPath, pkgRaw);\n    }\n  }\n\n  return remixConfig;\n}\n\nexport interface AddDependenciesOptions extends SpawnOptionsExtended {\n  saveDev?: boolean;\n}\n\n/**\n * Runs `npm i ${name}` / `pnpm i ${name}` / `yarn add ${name}`.\n */\nexport function addDependencies(\n  cliType: CliType,\n  names: string[],\n  opts: AddDependenciesOptions = {}\n) {\n  debug('Installing additional dependencies:');\n  for (const name of names) {\n    debug(` - ${name}`);\n  }\n  const args: string[] = [];\n\n  if (cliType === 'npm' || cliType === 'pnpm') {\n    args.push('install');\n    if (opts.saveDev) {\n      args.push('--save-dev');\n    }\n  } else {\n    // 'yarn'\n    args.push('add');\n    if (opts.saveDev) {\n      args.push('--dev');\n    }\n    const yarnVersion = execSync('yarn -v', { encoding: 'utf8' }).trim();\n    const isYarnV1 = semver.satisfies(yarnVersion, '1');\n    if (isYarnV1) {\n      // Ignoring workspace check is only needed on Yarn v1\n      args.push('--ignore-workspace-root-check');\n    }\n  }\n\n  // Don't fail if pnpm is being run at the workspace root\n  if (cliType === 'pnpm' && opts.cwd) {\n    if (existsSync(join(opts.cwd, 'pnpm-workspace.yaml'))) {\n      args.push('--workspace-root');\n    }\n  }\n\n  return spawnAsync(cliType, args.concat(names), opts);\n}\n\nexport function resolveSemverMinMax(\n  min: string,\n  max: string,\n  version: string\n): string {\n  const floored = semver.intersects(version, `>= ${min}`) ? version : min;\n  return semver.intersects(floored, `<= ${max}`) ? floored : max;\n}\n\nexport async function ensureResolvable(\n  start: string,\n  base: string,\n  pkgName: string\n): Promise<string> {\n  try {\n    const resolvedPkgPath = _require.resolve(`${pkgName}/package.json`, {\n      paths: [start],\n    });\n    const resolvedPath = dirname(resolvedPkgPath);\n    if (!relative(base, resolvedPath).startsWith(`..${sep}`)) {\n      // Resolved path is within the root of the project, so all good\n      debug(`\"${pkgName}\" resolved to '${resolvedPath}'`);\n      return resolvedPath;\n    }\n  } catch (err: any) {\n    if (err.code !== 'MODULE_NOT_FOUND') {\n      throw err;\n    }\n  }\n\n  // If we got to here then `pkgName` was not resolvable up to the root\n  // of the project. Try a couple symlink tricks, otherwise we'll bail.\n\n  // Attempt to find the package in `node_modules/.pnpm` (pnpm)\n  const pnpmDir = await walkParentDirs({\n    base,\n    start,\n    filename: 'node_modules/.pnpm',\n  });\n  if (pnpmDir) {\n    const prefix = `${pkgName.replace('/', '+')}@`;\n    const packages = await fs.readdir(pnpmDir);\n    const match = packages.find(p => p.startsWith(prefix));\n    if (match) {\n      const pkgDir = join(pnpmDir, match, 'node_modules', pkgName);\n      await ensureSymlink(pkgDir, join(start, 'node_modules'), pkgName);\n      return pkgDir;\n    }\n  }\n\n  // Attempt to find the package in `node_modules/.store` (npm 9+ linked mode)\n  const npmDir = await walkParentDirs({\n    base,\n    start,\n    filename: 'node_modules/.store',\n  });\n  if (npmDir) {\n    const prefix = `${basename(pkgName)}@`;\n    const prefixDir = join(npmDir, dirname(pkgName));\n    const packages = await fs.readdir(prefixDir);\n    const match = packages.find(p => p.startsWith(prefix));\n    if (match) {\n      const pkgDir = join(prefixDir, match, 'node_modules', pkgName);\n      await ensureSymlink(pkgDir, join(start, 'node_modules'), pkgName);\n      return pkgDir;\n    }\n  }\n\n  throw new Error(\n    `Failed to resolve \"${pkgName}\". To fix this error, add \"${pkgName}\" to \"dependencies\" in your \\`package.json\\` file.`\n  );\n}\n\nasync function ensureSymlink(\n  target: string,\n  nodeModulesDir: string,\n  pkgName: string\n) {\n  const symlinkPath = join(nodeModulesDir, pkgName);\n  const symlinkDir = dirname(symlinkPath);\n  const relativeTarget = relative(symlinkDir, target);\n\n  try {\n    const existingTarget = await fs.readlink(symlinkPath);\n    if (existingTarget === relativeTarget) {\n      // Symlink is already the expected value, so do nothing\n      return;\n    } else {\n      // If a symlink already exists then delete it if the target doesn't match\n      await fs.unlink(symlinkPath);\n    }\n  } catch (err: any) {\n    // Ignore when path does not exist or is not a symlink\n    if (err.code !== 'ENOENT' && err.code !== 'EINVAL') {\n      throw err;\n    }\n  }\n\n  await fs.symlink(relativeTarget, symlinkPath);\n  debug(`Created symlink for \"${pkgName}\"`);\n}\n\nexport function isESM(path: string): boolean {\n  // Figure out if the `remix.config` file is using ESM syntax\n  let isESM = false;\n  try {\n    _require(path);\n  } catch (err: any) {\n    isESM = err.code === 'ERR_REQUIRE_ESM';\n  }\n  return isESM;\n}\n"],
  "mappings": "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",
  "names": ["import_build_utils", "basename", "fs", "semver", "isESM"]
}
